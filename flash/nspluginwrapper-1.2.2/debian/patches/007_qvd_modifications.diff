Index: nspluginwrapper-1.2.2/Makefile
===================================================================
--- nspluginwrapper-1.2.2.orig/Makefile	2010-08-23 12:52:50.000000000 +0200
+++ nspluginwrapper-1.2.2/Makefile	2010-08-23 12:58:56.000000000 +0200
@@ -79,13 +79,11 @@
 ARCH_32 = $(ARCH)
 ifeq ($(biarch), yes)
 ARCH_32 = $(TARGET_ARCH)
-ifeq (,$(USE_SYSTEM_LSB))
 LSB_LIBS = $(LSB_OBJ_DIR)/libc.so $(LSB_OBJ_DIR)/libgcc_s_32.so
 LSB_LIBS += $(LSB_CORE_STUBS:%=$(LSB_OBJ_DIR)/%.so)
 LSB_LIBS += $(LSB_CORE_STATIC_STUBS:%=$(LSB_OBJ_DIR)/%.a)
 LSB_LIBS += $(LSB_DESKTOP_STUBS:%=$(LSB_OBJ_DIR)/%.so)
 endif
-endif
 
 LSB_TOP_DIR = $(SRC_PATH)/lsb-build
 LSB_INC_DIR = $(LSB_TOP_DIR)/headers
@@ -121,12 +119,8 @@
 npviewer_CFLAGS += -I$(LSB_INC_DIR)
 npviewer_CFLAGS += -I$(LSB_INC_DIR)/glib-2.0
 npviewer_CFLAGS += -I$(LSB_INC_DIR)/gtk-2.0
-ifeq (,$(USE_SYSTEM_LSB))
 npviewer_LDFLAGS = $(LDFLAGS_32) -L$(LSB_OBJ_DIR)
-else
-npviewer_LDFLAGS = $(LDFLAGS_32) -L/usr/lib32/
-endif
-npviewer_LDFLAGS += -lgtk-x11-2.0 -lgdk-x11-2.0 -lgobject-2.0 -ldl -lglib-2.0 -lgthread-2.0 -lX11 -lXt
+npviewer_LDFLAGS += -lgtk-x11-2.0 -lgdk-x11-2.0 -lgobject-2.0 -ldl -lglib-2.0 -lX11 -lXt
 else
 npviewer_CFLAGS += $(GTK_CFLAGS)
 npviewer_LDFLAGS = $(GTK_LDFLAGS) $(X_LDFLAGS)
@@ -163,11 +157,7 @@
 libxpcom_CFLAGS  = $(PIC_CFLAGS)
 ifeq ($(biarch),yes)
 libxpcom_CFLAGS += -I$(LSB_INC_DIR)
-ifeq (,$(USE_SYSTEM_LSB))
 libxpcom_LDFLAGS = $(LDFLAGS_32) -L$(LSB_OBJ_DIR)
-else
-libxpcom_LDFLAGS = $(LDFLAGS_32) -L/usr/lib32/
-endif
 endif
 
 libnoxshm_LIBRARY = libnoxshm.so
@@ -177,19 +167,14 @@
 libnoxshm_CFLAGS  = $(PIC_CFLAGS)
 ifeq ($(biarch),yes)
 libnoxshm_CFLAGS += -I$(LSB_INC_DIR)
-ifeq (,$(USE_SYSTEM_LSB))
 libnoxshm_LDFLAGS = $(LDFLAGS_32) -L$(LSB_OBJ_DIR)
-else
-libxpcom_LDFLAGS = $(LDFLAGS_32) -L/usr/lib32/
-endif
 endif
 
 npconfig_PROGRAM = npconfig
 npconfig_RAWSRCS = npw-config.c
 npconfig_SOURCES = $(npconfig_RAWSRCS:%.c=$(SRC_PATH)/src/%.c)
 npconfig_OBJECTS = $(npconfig_RAWSRCS:%.c=npconfig-%.o)
-npconfig_CFLAGS  = $(GLIB_CFLAGS)
-npconfig_LDFLAGS = $(GLIB_LDFLAGS) $(libdl_LDFLAGS)
+npconfig_LDFLAGS = $(libdl_LDFLAGS)
 ifneq (,$(findstring $(OS),netbsd dragonfly))
 # We will try to dlopen() the native plugin library. If that lib is
 # linked against libpthread, then so must our program too.
@@ -249,7 +234,6 @@
 FILES		+= $(addprefix $(LSB_TOP_DIR)/headers/,$(shell cat $(LSB_TOP_DIR)/headers/core_filelist))
 FILES		+= $(LSB_TOP_DIR)/headers/desktop_filelist
 FILES		+= $(addprefix $(LSB_TOP_DIR)/headers/,$(shell cat $(LSB_TOP_DIR)/headers/desktop_filelist))
-ifeq (,$(USE_SYSTEM_LSB))
 FILES		+= $(LSB_SRC_DIR)/LibNameMap.txt
 FILES		+= $(LSB_SRC_DIR)/core_filelist
 FILES		+= $(LSB_SRC_DIR)/core_static_filelist
@@ -259,7 +243,6 @@
 FILES		+= $(patsubst %,$(LSB_SRC_DIR)/%.c,$(LSB_CORE_STATIC_STUBS))
 FILES		+= $(patsubst %,$(LSB_SRC_DIR)/%.c,$(LSB_DESKTOP_STUBS))
 FILES		+= $(patsubst %,$(LSB_SRC_DIR)/%.Version,$(LSB_DESKTOP_STUBS))
-endif
 
 all: $(TARGETS)
 
@@ -394,13 +377,8 @@
 npwrapper-%.os: $(SRC_PATH)/src/%.c
 	$(CC) -o $@ -c $< $(PIC_CFLAGS) $(CPPFLAGS) $(npwrapper_CFLAGS) -DBUILD_WRAPPER
 
-ifeq (,$(USE_SYSTEM_LSB))
 $(npviewer_PROGRAM): $(npviewer_OBJECTS) $(npviewer_MAPFILE) $(LSB_OBJ_DIR) $(LSB_LIBS)
 	$(CC) $(LDFLAGS_32) -o $@ $(npviewer_OBJECTS) $(npviewer_LDFLAGS)
-else
-$(npviewer_PROGRAM): $(npviewer_OBJECTS) $(npviewer_MAPFILE)
-	$(CC) $(LDFLAGS_32) -o $@ $(npviewer_OBJECTS) $(npviewer_LDFLAGS)
-endif
 
 npviewer-%.o: $(SRC_PATH)/src/%.c
 	$(CC) $(CFLAGS_32) -o $@ -c $< $(CPPFLAGS) $(npviewer_CFLAGS) -DBUILD_VIEWER
@@ -408,37 +386,22 @@
 npviewer-%.o: $(SRC_PATH)/src/%.cpp
 	$(CXX) $(CFLAGS_32) -o $@ -c $< $(CPPFLAGS) $(npviewer_CFLAGS) -DBUILD_VIEWER
 
-ifeq (,$(USE_SYSTEM_LSB))
 $(npplayer_PROGRAM): $(npplayer_OBJECTS) $(npplayer_MAPFILE) $(LSB_OBJ_DIR) $(LSB_LIBS)
 	$(CC) $(LDFLAGS) -o $@ $(npplayer_OBJECTS) $(npplayer_LDFLAGS)
-else
-$(npplayer_PROGRAM): $(npplayer_OBJECTS) $(npplayer_MAPFILE)
-	$(CC) $(LDFLAGS) -o $@ $(npplayer_OBJECTS) $(npplayer_LDFLAGS)
-endif
 
 npplayer-%.o: $(SRC_PATH)/src/%.c
 	$(CC) $(CFLAGS) -o $@ -c $< $(CPPFLAGS) $(npplayer_CFLAGS) -DBUILD_PLAYER
 npplayer-%.o: $(SRC_PATH)/src/tidy/%.c
 	$(CC) $(CFLAGS) -o $@ -c $< $(CPPFLAGS) $(npplayer_CFLAGS) -DBUILD_PLAYER
 
-ifeq (,$(USE_SYSTEM_LSB))
 $(libxpcom_LIBRARY): $(libxpcom_OBJECTS) $(LSB_OBJ_DIR) $(LSB_LIBS)
 	$(CC) $(LDFLAGS_32) $(DSO_LDFLAGS) -o $@ $(libxpcom_OBJECTS) $(libxpcom_LDFLAGS) -Wl,$(LD_soname),libxpcom.so
-else
-$(libxpcom_LIBRARY): $(libxpcom_OBJECTS)
-	$(CC) $(LDFLAGS_32) $(DSO_LDFLAGS) -o $@ $(libxpcom_OBJECTS) $(libxpcom_LDFLAGS) -Wl,$(LD_soname),libxpcom.so
-endif
 
 libxpcom-%.o: $(SRC_PATH)/src/%.c
 	$(CC) $(CFLAGS_32) -o $@ -c $< $(CPPFLAGS) $(libxpcom_CFLAGS) -DBUILD_XPCOM
 
-ifeq (,$(USE_SYSTEM_LSB))
 $(libnoxshm_LIBRARY): $(libnoxshm_OBJECTS) $(LSB_OBJ_DIR) $(LSB_LIBS)
 	$(CC) $(LDFLAGS_32) $(DSO_LDFLAGS) -o $@ $(libnoxshm_OBJECTS) $(libnoxshm_LDFLAGS) -Wl,$(LD_soname),libnoxshm.so
-else
-$(libnoxshm_LIBRARY): $(libnoxshm_OBJECTS)
-	$(CC) $(LDFLAGS_32) $(DSO_LDFLAGS) -o $@ $(libnoxshm_OBJECTS) $(libnoxshm_LDFLAGS) -Wl,$(LD_soname),libnoxshm.so
-endif
 
 libnoxshm-%.o: $(SRC_PATH)/src/%.c
 	$(CC) $(CFLAGS_32) -o $@ -c $< $(CPPFLAGS) $(libnoxshm_CFLAGS)
@@ -447,7 +410,7 @@
 	$(CC) -o $@ $(npconfig_OBJECTS) $(npconfig_LDFLAGS)
 
 npconfig-%.o: $(SRC_PATH)/src/%.c
-	$(CC) -o $@ -c $< $(CPPFLAGS) $(CFLAGS) $(npconfig_CFLAGS)
+	$(CC) -o $@ -c $< $(CPPFLAGS) $(CFLAGS)
 
 $(nploader_PROGRAM): $(nploader_SOURCES)
 	sed -e "s|%NPW_LIBDIR%|$(pkglibdir)|" $< > $@
Index: nspluginwrapper-1.2.2/src/npw-remote-agent-info.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ nspluginwrapper-1.2.2/src/npw-remote-agent-info.c	2010-08-23 12:52:51.000000000 +0200
@@ -0,0 +1,266 @@
+/*
+ * npw-remote-agent-info.c
+ *
+ * We need to use libcurl to fetch a URL for the plugin, because
+ * the initialization of the RPC channel is before the plugin is initialized
+ * and we don't have the NPP instance for NPP_GetURL (or similar funcs)
+ *
+ * Description:
+ *
+ * If NPW_USE_TCPIP is defined then we use TCP sockets instead of UNIX sockets
+ *
+ * If NPW_REMOTE_AGENT_URI is defined
+ *
+ *
+ * Note: Problem in compiling npw-remote-agent-info as 64bits... in 32bit
+ *
+ * 21/8/2010 - Nito@Qindel.ES
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include "sysdeps.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <curl/curl.h>
+#include <curl/types.h>
+#include <curl/easy.h>
+#include "npw-use-tcp-sockets.h"
+#include "npw-remote-agent-info.h"
+
+#define DEBUG 1
+#include "debug.h"
+
+//#define MYURL "http://localhost/port"
+#define USERAGENT "QVDnswrapper/1.0"
+#define MAXKEYS 128
+#define MAX_KEY_SIZE 10
+#define MAX_VALUE_SIZE 10
+struct MemoryStruct {
+  char *memory;
+  size_t size;
+};
+
+
+static int rpc_port = 0;
+const char *npw_agent_uri = NULL;
+
+
+
+/******************************************************************************
+ * This is a replacement for strsep which is not portable (missing on
+ Solaris).
+ */
+ static char* getToken(char** str, const char* delims)
+ {
+     char* token;
+
+     if (*str==NULL) {
+         /* No more tokens */
+         return NULL;
+     }
+
+     token=*str;
+     while (**str!='\0') {
+         if (strchr(delims,**str)!=NULL) {
+             **str='\0';
+             (*str)++;
+             return token;
+         }
+         (*str)++;
+     }
+     /* There is no other token */
+     *str=NULL;
+     return token;
+ }
+
+
+static void *myrealloc(void *ptr, size_t size)
+{
+  /* There might be a realloc() out there that doesn't like reallocing
+     NULL pointers, so we take care of it here */
+  if(ptr)
+    return realloc(ptr, size);
+  else
+    return malloc(size);
+}
+
+
+static size_t
+WriteMemoryCallback(void *ptr, size_t size, size_t nmemb, void *data)
+{
+  size_t realsize = size * nmemb;
+  struct MemoryStruct *mem = (struct MemoryStruct *)data;
+
+  mem->memory = myrealloc(mem->memory, mem->size + realsize + 1);
+  if (mem->memory) {
+    memcpy(&(mem->memory[mem->size]), ptr, realsize);
+    mem->size += realsize;
+    mem->memory[mem->size] = 0;
+  }
+  return realsize;
+}
+
+void init_array(char **array) {
+  memset(array, 0, MAXKEYS * sizeof(char *));
+}
+
+void free_array(char **array) {
+  int i;
+  char **ptr;
+  ptr=array;
+  for (i = 0; i < MAXKEYS; ++i) {
+    if (*ptr) {
+      free(*ptr);
+      *ptr=NULL;
+    }
+    ++ ptr;
+  }
+}
+
+void assign(char **ptr, const char *value) {
+  int len;
+  len = strlen(value);
+  *ptr = malloc(len + 1);
+  strncpy(*ptr, value, len);
+}
+
+//Duplicate entries ocupy space, but only the first is used
+int parse_page(struct MemoryStruct *chunk, char **keys, char **values) {
+  char *line, *copy, **copy_ptr, *copy_free_ptr, format[32],
+    key[MAX_KEY_SIZE + 1], value[MAX_VALUE_SIZE + 1];
+  int parsed_elements, keys_parsed;
+
+  // Format string to parse chars
+  sprintf(format, " %%%d[^= ] = %%%d[^#] ", MAX_KEY_SIZE, MAX_VALUE_SIZE);
+
+  // Set end of string for long keys and values
+  key[MAX_KEY_SIZE] = 0;
+  value[MAX_VALUE_SIZE] = 0 ;
+
+  // Copy the buffer to be parsed
+  copy_free_ptr = copy = malloc(chunk->size);
+  memcpy(copy, chunk->memory, chunk->size);
+  copy_ptr = &copy;
+
+
+  // Parse line by line
+  line = getToken(copy_ptr, "\n");
+  for (keys_parsed=0; *copy_ptr != NULL; line = getToken(copy_ptr, "\n")) {
+    printf("Parsing line <%s>\n", line);
+    if (line == NULL)       // Should never happen
+      break;
+
+    if (keys_parsed >= MAXKEYS) {
+      printf("Too many keys in the file. Skipping the rest\n");
+      break;
+    }
+
+    if (strlen(line) == 0) {
+      printf ("Skipped blank line\n");
+      continue;
+    }
+
+    if (line[0] == '#') {
+      printf ("Skipped comment\n");
+      continue;
+    }
+    if ((parsed_elements = sscanf(line, format, key, value)) < 2) {
+      printf ("line <%s> not recognized key=%s, value=%s, int=%d\n", line, key, value, parsed_elements);
+      continue;
+    }
+    printf("key=<%s>, value=<%s>\n", key, value);
+    assign(keys, key);
+    keys ++;
+    assign(values, value);
+    values ++;
+    keys_parsed ++;
+  }
+  free(copy_free_ptr);
+  return 0;
+}
+
+// Not defined and empty is the same
+const char * getvalue(char **keys, char**values, const char *key) {
+  int i;
+  for(i=0; i < MAXKEYS; i++) {
+    if ((*keys == NULL) || (*values == NULL)) {
+      break;
+    }
+    if (!strcmp(key, *keys)){
+      return *values;
+    }
+    keys ++;
+    values ++;
+  }
+  return "";
+}
+
+
+int fetch_remote_agent_url(const char *myurl, struct MemoryStruct *chunk) {
+  CURL *handle;
+  CURLcode res;
+  char error_buffer[CURL_ERROR_SIZE];
+
+
+  if (curl_global_init(CURL_GLOBAL_ALL)) {
+    fprintf(stderr, "Error intializing curl for url %s", myurl);
+    return -1;
+  }
+
+  handle = curl_easy_init();
+  curl_easy_setopt(handle, CURLOPT_URL, myurl);
+  curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
+  curl_easy_setopt(handle, CURLOPT_WRITEDATA, (void *)chunk);
+  curl_easy_setopt(handle, CURLOPT_USERAGENT, USERAGENT);
+  curl_easy_setopt(handle, CURLOPT_ERRORBUFFER, error_buffer);
+  res = curl_easy_perform(handle);
+  if (res) {
+    fprintf(stderr, "Error getting URL %s: %s", myurl, error_buffer);
+  }
+  curl_easy_cleanup(handle);
+  curl_global_cleanup();
+  return res;
+}
+
+
+
+int return_rpc_port() {
+  return rpc_port++;
+}
+
+int verify_if_using_tcp_sockets() {
+  //  int use_tcp = 0;
+  // If NPW_USE_TCPIP_PORT or NPW_REMOTE_AGENT_ENV is defined then use tcp_sockets
+  const char *npw_agent_uri = getenv(NPW_USE_TCPIP_PORT);
+  if (npw_agent_uri)
+    rpc_port = atoi(npw_agent_uri);
+  if (rpc_port < 1024 || rpc_port > 65535) {
+    D(bug("%s defined: %s. But the socket is < 1024 or > 65535. Not using TCP sockets\n", NPW_USE_TCPIP_PORT, npw_agent_uri));
+  }
+  set_tcp_sockets();
+  D(bug("%s defined: %s. Using tcp sockets\n", NPW_USE_TCPIP_PORT, npw_agent_uri));
+  npw_agent_uri = getenv(NPW_REMOTE_AGENT_ENV);
+  if (npw_agent_uri) {
+    set_tcp_sockets();
+    D(bug("%s defined: %s. Using tcp sockets\n", NPW_REMOTE_AGENT_ENV, npw_agent_uri));
+  }
+}
+
+void set_remote_connection_path(char *connection_path) {
+  // getenv...
+  sprintf(connection_path, "%s:%d", NPW_RPC_TEST_SERVER, return_rpc_port());
+}
Index: nspluginwrapper-1.2.2/src/npw-remote-agent-info.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ nspluginwrapper-1.2.2/src/npw-remote-agent-info.h	2010-08-23 12:52:51.000000000 +0200
@@ -0,0 +1,46 @@
+/*
+ * npw-agent-info.h
+ *
+ * 21/8/2010 - Nito@Qindel.ES
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef NPW_AGENT_INFO_H
+#define NPW_AGENT_INFO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Use TCP/IP communication
+//#define NPW_RPC_USE_TCPIP 1
+//#define NPW_RPC_TEST_PORT 2111
+//#define NPW_RPC_TEST_PORT2 3111
+#define NPW_RPC_TEST_SERVER "127.0.0.1"
+//#define NPW_RPC_TEST_SERVER2 "127.0.0.1"
+#define MAX_CONNECTION_PATH 128
+  // define This environment var to 1 to use remote agent
+#define NPW_REMOTE_AGENT_ENV "NPW_REMOTE_AGENT_URI"
+  // define This environment var to 1 to use TCP sockets
+#define NPW_USE_TCPIP_PORT "NPW_USE_TCPIP_PORT"
+
+extern void set_remote_connection_path(char *connection_path);
+extern int verify_if_using_tcp_sockets();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: nspluginwrapper-1.2.2/src/npw-use-tcp-sockets.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ nspluginwrapper-1.2.2/src/npw-use-tcp-sockets.c	2010-08-23 12:52:51.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * npw-use-tcp-sockets.c
+ *
+ *
+ * Note: Problem in compiling npw-remote-agent-info as 64bits... in 32bit
+ *
+ * 21/8/2010 - Nito@Qindel.ES
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include "sysdeps.h"
+
+#define DEBUG 1
+#include "debug.h"
+
+static int use_tcp_sockets_flag = 0;
+
+int use_tcp_sockets() {
+  return use_tcp_sockets_flag;
+}
+
+int set_tcp_sockets() {
+  use_tcp_sockets_flag = 1;
+  return use_tcp_sockets_flag;
+}
+
+int unset_tcp_sockets() {
+  use_tcp_sockets_flag = 0;
+  return use_tcp_sockets_flag;
+}
Index: nspluginwrapper-1.2.2/src/npw-use-tcp-sockets.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ nspluginwrapper-1.2.2/src/npw-use-tcp-sockets.h	2010-08-23 12:52:51.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * use-tcp-sockets.h
+ *
+ * 23/8/2010 - Nito@Qindel.ES
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef NPW_USE_TCP_SOCKETS_H
+#define NPW_USE_TCP_SOCKETS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int use_tcp_sockets();
+extern int set_tcp_sockets();
+extern int unset_tcp_sockets();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
