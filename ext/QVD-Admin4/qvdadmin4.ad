
= La API del sistema de administración de QVD4


La API es una aplicación `Mojolicious::Lite` definida en el archivo `wat.pl`. Es una interfaz REST que recibe una _query_ en formato JSON, ejecuta la tarea  correspondiente a esa petición, y devuelve a su vez un JSON como respuesta. 

=== `QVD::Admin4::REST`

El cerebro de la aplicación es un objeto `QVD::Admin4::REST`. Cuando la API recibe una _query_, se la pasa a este objeto, que será el encargado de orquestar todo el procesamiento y devolver una respuesta. Concretamente, el objeto `QVD::Admin4::REST` articula las siguientes clases para llevar a cabo su cometido: `QVD::Admin4::Action`, `QVD::Admin4::REST::Model`, `QVD::Admin4::REST::Request` y `QVD::Admin4`. 

`QVD::Admin4` proporciona todos los métodos que en última instancia ejecutan las acciones que piden las _queries_. Por tanto, pudiera decirse que `QVD::Admin4::REST`, al recibir una petición, se la pasa como argumento a un método de `QVD::Admin4` y devuelve el resultado que arroja este. 

Pero la realidad es más compleja. Téngase en cuenta que a cada acción soportada por la API le corresponde un método concreto de `QVD::Admin4`. Así pues, ¿cómo se establece la correspondencia entre el nombre de la acción solicitada en la _query_ y el método que debe ejecutarse en `QVD::Admin4`?  Del siguiente modo. Tomando como parámetro el nombre de la acción solicitada, se crea un nuevo objeto `QVD::Admin4::Action`. Este objeto proporciona la configuración básica de la acción en cuestión. Entre otras cosas, especifica el método de `QVD::Admin4` a utilizar.

Además, de acuerdo con otras especificaciones proporcionadas por el objeto `QVD::Admin4::Action`, se crea un objeto `QVD::Admin4::REST::Model`: un modelo que define cómo debe ser una acción del tipo especificado. Este modelo se utilizará para comprobar que la petición recibida es legítima, y para ajustarla al formato que esperan los métodos de `QVD::Admin4`.

Así pues, la _query_ que recibe `QVD::Admin4::REST` no es exactamente la que este le pasa al método de `QVD::Admin4`. En realidad, la _query_ se les pasa a estos métodos en forma de objeto `QVD::Admin4::REST::Request`. Este objeto representa una _query_ correcta y expresada en un formato concreto. El constructor del objeto `QVD::Admin4::REST::Request` toma como parámetros la _query_ y su modelo `QVD::Admin4::REST::Model` correspondiente. Siempre a partir del modelo, comprueba que la _query_ sea correcta y la traduce al formato necesario. 

En resumen, la API recibe una _query_ en formato JSON. Esta _query_ se le pasa al objeto `QVD::Admin4::REST`, encargado de gestionarla y devolver una respuesta. Este objeto recupera cierta información relevante sobre la acción solicitada, en forma de objetos `QVD::Admin4::Action` y `QVD::Admin4::REST::Model`. Con dicha información crea un objeto `QVD::Admin4::REST::Request` (una nueva versión de la _query_,  corregida y ajustada a un determinado formato). A continuación, ejecuta el método correspondiente a la acción solicitada pasándole como argumento el objeto `QVD::Admin4::REST::Request`. La salida de ese método es lo que la API devuelve como respuesta, también en formato JSON.

=== `QVD::Admin4::REST::JSON`

A partir de la _query_ JSON, se crea un objeto `QVD::Admin4::REST::JSON`. Es un _wrapper_ que permite gestionar la _query_ con facilidad. A partir de aquí, toda la información que se quiera sacar de la _query_ se le consultará a este objeto.

=== `QVD::Admin4::Action`

Se crea un objeto `QVD::Admin4::Action`, con un parámetro obligatorio `name` (el nombre de la acción que se está pidiendo realizar, tomado de la _query_). Este objeto contiene la información básica, de arranque, de la acción que se ha solicitado. Concretamente, cuenta con los siguientes atributos:

* El atributo `type_of_action` establece el tipo de  acción solicita (hay acciones de visualización, de creación, de actualización, de borrado...). 

* El atributo `qvd_object` establece el tipo de objeto de QVD al que la acción afecta: `vm`, `user`, `osf`, `di`, `host`, etc. 

* El atributo `restmethod` establece el método que debe ejecutarse en `QVD::Admin4::REST` para invocar la acción.

* El atributo `admin4method` establece el método que debe ejecutarse en `QVD::Admin4` para invocar la acción.

NOTE: La clase `QVD::Admin4::Action` define una lista cerrada de posibles acciones que la API permite realizar. El nombre de la acción solicitada se le pasa al constructor de `QVD::Admin4::Action` en el parámetro `name`. Si el valor de `name` no estuviera contemplado en la lista de acciones disponibles, la creación del objeto `QVD::Admin4::Action` fallaría. Este es el sistema que comprueba  que las peticiones que se hacen a la API estén soportadas por ella. En la clase `QVD::Admin4::Action`  también se codifican, para cada acción disponible en la API, los acls necesarios para ejecutarla. Una vez creado el objeto, se comprueba que el administrador que hace la petición cuente con los permisos necesarios. En caso contrario, se lanza un error.

=== `QVD::Admin4::REST::Model`

A partir de los valores de `type_of_action` y `qvd_object` se crea un nuevo objeto `QVD::Admin4::REST::Model`. Este objeto es un modelo que define qué filtros admite una acción, qué argumentos, qué criterios de ordenación; qué campos devuelve; qué valores por defecto pudieran tener esos elementos; qué acls necesita un administrador para usarlos; cómo se traduce cada uno de ellos al formato adecuado para consultar a la base de datos, etc. Un objeto `QVD::Admin4::REST::Model`, es, en definitiva, la definición de una _query_ correcta, y el patrón que permite traducir la _query_ al formato de la base de datos.

NOTE: Como puede verse, el sistema no define _ad hoc_ un modelo para cada acción posible, sino para cada par `type_of_action` / `qvd_object`. El cruce de estos dos criterios se hace de forma dinámica. Las clases `QVD::Admin4::Action` y `QVD::Admin4::REST::Model` permiten codificar la API de modo declarativo. En `QVD::Admin4::Action` se codifica la información de arranque: se listan las acciones disponibles, se tipifican conforme a criterios relevantes en el sistema, se establece qué acls son necesarios para ejecutarlas, y qué métodos deben invocarse para ello. En `QVD::Admin4::REST::Model` se define qué filtros, argumentos, criterios de ordenación, etc. son legítimos, qué información se devuelve en cada caso, y cómo se expresa todo ello en términos de la base de datos.

=== `QVD::Admin4::REST::Request`

Una vez creados el _wrapper_ para la _query_ de entrada (`QVD::Admin4::REST::JSON`) y el modelo de la acción solicitada (`QVD::Admin4::REST::Model`) ya es posible crear una petición de tipo `QVD::Admin4::REST::Request`. Este objeto será lo que se le pase como argumento al método encargado de ejecutar la acción (un método de `QVD::Admin4`). Representa una petición que puede hacerse a la base de datos a través de `DBIx::Class`. Provee toda la información necesaria para efectuar la petición: tabla a la que consultar, _joins_ de otras tablas, filtros, argumentos si los hubiera, criterios de ordenación, etc. Este objeto se construye cotejando la _query_ de entrada con el modelo correspondiente. Su constructor lanza una serie de chequeos que comprueban que, conforme al modelo, la _query_ es correcta: los filtros, argumentos... son adecuados; y el administrador que hace la petición tiene acls suficientes para utilizar esos elementos. También se fuerzan, cuando es necesario, ciertos filtros, como el de tenant (un administrador de tenant solo debe poder ver la información de su tenant). Además, se traducen los elementos de la _query_ al formato utilizado por `DBIx::Class`.

=== `QVD::Admin4`

Por último, se ejecuta propiamente la acción. Para ello, se usan los atributos `restmethod` y `admin4method` de `QVD::Admin4::Action`. El atributo `restmethod` especifica el nombre de un método de `QVD::Admin4::REST` (en adelante *R*). Y el atributo `admin4method` especifica el nombre de un método de `QVD::Admin4` (en adelante *A*). Para ejecutar la acción, en primer lugar se ejecuta *R*, y dentro de *R* se ejecuta *A*. En realidad, es este segundo el método  que propiamente ejecuta la acción (la clase `QVD::Admin4` es la  que opera sobre la base de datos). La razón de que *A* no se ejecute directamente, sino a través de *R*, es que `QVD::Admin4` cuenta con distintos tipos de acciones, y cada uno de ellos se invoca de un modo distinto. El método *R* es el encargado de invocar *A* del modo adecuado.

NOTE: Los métodos *R* posibles son `process_standard_query` (para las acciones de funcionamiento regular, la inmensa mayoría), `process_ad_hoc_query` (para acciones de funcionamiento particular) y  `process_multiple_query` (para acciones que requieren la ejecución de múltiples métodos *A*). Los métodos *A* pueden llegar a ser muchos, pero la inmensa mayor parte de las acciones de funcionamiento regular usan los mismos métodos: `select`, `update`, `create`, `create_or_update`, `delete`. En realidad, los objetos `QVD::Admin4::REST::Model` y `QVD::Admin4::REST::Request` vistos arriba están pensados solo para las acciones regulares (ejecutadas desde `process_standard_query`). De hecho, el objeto  `QVD::Admin4::REST::Request` se crea en `process_standard_query`. El resto de acciones se ejecutan mediante métodos _ad hoc_ que efectúan sus chequeos de forma independiente al sistema general aquí descrito.
