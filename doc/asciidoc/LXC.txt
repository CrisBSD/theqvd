Linux Containers
================
David Serrano
v0.1, Jan 2011

Setup
-----

Installing lxc
~~~~~~~~~~~~~~

Just run as root:

----
# apt-get install lxc
----

Then check that the needed kernel compilation options are in place:

----
$ lxc-checkconfig 
Kernel config /proc/config.gz not found, looking in other places...
Found kernel config file /boot/config-2.6.32-27-generic
--- Namespaces ---
Namespaces: enabled
Utsname namespace: enabled
Ipc namespace: enabled
Pid namespace: enabled
User namespace: enabled
Network namespace: enabled
Multiple /dev/pts instances: enabled

--- Control groups ---
Cgroup: enabled
Cgroup namespace: enabled
Cgroup device: enabled
Cgroup sched: enabled
Cgroup cpu account: enabled
Cgroup memory controller: enabled
Cgroup cpuset: enabled

--- Misc ---
Veth pair device: enabled
Macvlan: enabled
Vlan: enabled
File capabilities: enabled
----

Setting up a network bridge
~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this example, we replace eth1, which has IP 10.1.0.101, with a bridge:

----
#auto eth1
#iface eth1 inet static
# ...

auto br0
iface br0 inet static
    address 10.1.0.101
    netmask 255.255.255.0
    gateway 10.1.0.1
    bridge_ports eth1
    bridge_fd 0
----

Creating a new container
~~~~~~~~~~~~~~~~~~~~~~~~

General layout
^^^^^^^^^^^^^^
----
/somewhere
  \_ container1.conf
  \_ container2.conf
  \_ container1
  |    \_ bin
  |    \_ dev
  |    \_ etc
  |    \_ ...
  \_ container2
       \_ bin
       \_ dev
       \_ etc
       \_ ...
----

Configuration file
^^^^^^^^^^^^^^^^^^
----
lxc.utsname = qvdimg
lxc.tty = 4
lxc.network.type = veth
lxc.network.flags = up
lxc.network.link = br0
lxc.network.name = eth1
lxc.network.mtu = 1500
lxc.network.hwaddr = 54:52:00:42:42:42
lxc.network.ipv4 = 0.0.0.0
lxc.rootfs = /home/qvd/cont/qvdimg/root
#lxc.mount.entry = /home/user554543 /home/qvd/cont/qvdimg/home none bind 0 0
#lxc.mount = /path/to/some/specific/fstab
lxc.cgroup.devices.deny = a
# /dev/null and zero
lxc.cgroup.devices.allow = c 1:3 rwm
lxc.cgroup.devices.allow = c 1:5 rwm
# consoles
lxc.cgroup.devices.allow = c 5:1 rwm
lxc.cgroup.devices.allow = c 5:0 rwm
lxc.cgroup.devices.allow = c 4:0 rwm
lxc.cgroup.devices.allow = c 4:1 rwm
# /dev/{,u}random
lxc.cgroup.devices.allow = c 1:9 rwm
lxc.cgroup.devices.allow = c 1:8 rwm
# /dev/pts/* - pts namespaces are "coming soon"
lxc.cgroup.devices.allow = c 136:* rwm
lxc.cgroup.devices.allow = c 5:2 rwm
# rtc
lxc.cgroup.devices.allow = c 254:0 rwm
----

  - 'lxc.utsname' specifies the hostname of the container.
  - 'lxc.network.type' introduces a new network interface inside the container. Everytime it appears in the configuration, a new interface is configured.
  - 'lxc.network.link' refers to the bridge we just configured earlier.
  - 'lxc.network.name' is the name that this network interface will have inside the container. Can be virtually any string.
  - 'lxc.network.hwaddr' is needed for DHCP, not needed otherwise.
  - 'lxc.network.ipv4' can be 0.0.0.0 if DHCP is going to be used.

Modifications to the container filesystem
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

/dev
^^^^
Only the minimum set of devices should exist under /dev. The daemon udev doesn't work under LXC, so the /dev management has to be done by hand. Following is a set of shell commands needed to create these devices. They assume that the root filesystem path is specified by the shell variable $ROOTFS, *make sure* this is the case, or the system's /dev will be wiped clean!

----
echo $ROOTFS
rm -rf $ROOTFS/dev
mkdir $ROOTFS/dev
mkdir -m 755 $ROOTFS/dev/pts
mkdir -m 1777 $ROOTFS/dev/shm 
mknod -m 600 $ROOTFS/dev/console c 5 1
mknod -m 666 $ROOTFS/dev/full c 1 7
mknod -m 600 $ROOTFS/dev/initctl p
mknod -m 666 $ROOTFS/dev/null c 1 3 
mknod -m 666 $ROOTFS/dev/ptmx c 5 2
mknod -m 666 $ROOTFS/dev/random c 1 8
mknod -m 666 $ROOTFS/dev/tty c 5 0
mknod -m 666 $ROOTFS/dev/tty0 c 4 0
mknod -m 666 $ROOTFS/dev/tty1 c 4 1
mknod -m 666 $ROOTFS/dev/tty2 c 4 2
mknod -m 666 $ROOTFS/dev/tty3 c 4 3
mknod -m 666 $ROOTFS/dev/tty4 c 4 4
mknod -m 666 $ROOTFS/dev/urandom c 1 9
mknod -m 666 $ROOTFS/dev/zero c 1 5
----

/etc/hostname and /etc/hosts
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The container's hostname must be placed in these files.

/etc/fstab
^^^^^^^^^^
The entries for the root filesystem and the swap must be removed/commented.

init scripts (/etc/init in Ubuntu)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Most init scripts should be removed since they deal with daemons not needed (or even inconvenient) inside a container. For example, everything hardware-related (ACPI, ALSA, avahi, clock, IRQs, udev) must be moved out of the way. What I did is place them in $ROOTFS/etc/init.moved instead of deleting them. This is what was left:

(TODO: I'm not sure about dbus - dserrano)

(TODO: I think mountall.conf and friends can be included in some particular cases - dserrano)

----
anacron.conf
atd.conf
cron.conf
dmesg.conf
hostname.conf
networking.conf
rc.conf
rc-sysinit.conf
rsyslog.conf
ssh.conf
tty1.conf
tty2.conf
tty3.conf
ufw.conf
----

Note the absence of pretty basic stuff like rcS for example. It's actually not needed. Another item worth mentioning is ttyS0.conf. Since it deals directly with the hardware, it shouldn't run inside a container.

After the cleanup, create a small script, lxc.conf, with these contents:

----
# LXC – Fix init sequence to have LXC containers boot with upstart

# description “Fix LXC container - Lucid”

start on startup

task
pre-start script
    mount -t proc proc /proc || true
    mount -t devpts devpts /dev/pts || true
    mount -t sysfs sys /sys || true
    mount -t tmpfs varrun /var/run
    mount -t tmpfs varlock /var/lock
    mkdir -p /var/run/network
    touch /var/run/utmp
    chmod 664 /var/run/utmp
    chown root.utmp /var/run/utmp
    if [ "$(find /etc/network/ -name upstart -type f)" ]; then
        chmod -x /etc/network/*/upstart || true
    fi
end script

script
    start networking
    initctl emit filesystem --no-wait
    initctl emit local-filesystems --no-wait
    initctl emit virtual-filesystems --no-wait
    init 2
end script
----

(TODO: I guess the pre-start script could be dealt with elsewhere - dserrano)

Lastly, the script rc-sysinit.conf must be modified to run after system startup event, instead of waiting to the filesystem event. Modify the line that begins with "start on" so it reads like:

----
start on startup
----

A quick sed oneliner can do this (use at your own risk):

----
sed -i -e '/^start on/s/\(start on\) .*/\1 startup/' /tmp/rc-sysinit.conf
----


Usage
-----
  - 'lxc-create' creates the container, which isn't more than a data structure.

    lxc-create -n name -f /path/to/config-file

  - 'lxc-ls' lists the existing containers.

    lxc-ls

  - 'lxc-start' brings the container up.

    lxc-start -n name
    lxc-start -n name -d                   ## suppress output
    lxc-start -n name -d -o /tmp/lxc.log   ## send output to a log file
    lxc-start -n name -l DEBUG -o $(tty)   ## for debugging

  - 'lxc-console' connects to one of the container's ttys. After closing the session, you can get out of lxc-console with the key sequence "C-A q".

    lxc-console -n name -t 1   ## connects to tty1

  - 'lxc-info' shows information about the specified container.

    lxc-info -n name

  - 'lxc-ps' shows processes running inside the container.

    lxc-ps -n name

  - 'lxc-stop' kills all processes in the container, effectively stopping it.

    lxc-stop -n name

  - 'lxc-destroy' just removes the data structure.

    lxc-destroy -n name
